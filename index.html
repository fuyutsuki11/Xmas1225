<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ³åœ£è¯èŠ‚å¿«ä¹ğŸŒ³</title>
    <style>
        body { 
            margin: 0; 
            /* èƒŒæ™¯æ”¹ä¸ºæ·±ç´«è‰²å¾„å‘æ¸å˜ï¼Œæå‡ç©ºé—´æ„Ÿ */
            background: radial-gradient(circle at center, #1a0510 0%, #050103 100%); 
            overflow: hidden; 
            touch-action: none; 
        }
    </style>
</head>
<body>
    <audio id="bgm" loop src="bgm.mp3" muted preload="auto"></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
    document.addEventListener("WeixinJSBridgeReady", function () {
    const audio = document.getElementById('bgm');
    audio.play();
}, false);
    const audio = document.getElementById('bgm');
    let scene, camera, renderer, points, snowPoints, haloPoints;
    let mixedPos, mixedCol, vPoints = [];
    const COUNT = 35000; 
    const HALO_COUNT = 18000; 
    
    const tree = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const text = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const state = { progress: 0 }; 

    let targetRotationY = 0, currentRotationY = 0, isDragging = false, lastX = 0;
    const AUTO_ROTATION_SPEED = 0.0012; 

    // ä¼˜åŒ–åçš„é«˜äº®åœ†ç‚¹è´´å›¾
    function createCircleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)'); // ä¸­å¿ƒçº¯ç™½
        gradient.addColorStop(0.3, 'rgba(255,255,255,0.9)');
        gradient.addColorStop(0.6, 'rgba(255,255,255,0.1)'); // è¾¹ç¼˜æ›´æœ‰åŠ›åœ°æ”¶ç¼©
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
    }

    function prepareText() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1000; canvas.height = 400;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 120px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('MERRY', 500, 150);
        ctx.fillText('CHRISTMAS', 500, 300);
        const data = ctx.getImageData(0,0,1000,400).data;
        for(let y=0; y<400; y+=2) {
            for(let x=0; x<1000; x+=2) {
                if(data[(y*1000+x)*4] > 128) {
                    vPoints.push({x:(x-500)*0.12, y:(200-y)*0.12});
                }
            }
        }
    }

    function init() {
        prepareText();
        const dotTexture = createCircleTexture();
        
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
        camera.position.set(0, 5, 80);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        createData();
        
        const geo = new THREE.BufferGeometry();
        mixedPos = new Float32Array(tree.pos);
        mixedCol = new Float32Array(tree.col);
        geo.setAttribute('position', new THREE.BufferAttribute(mixedPos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(mixedCol, 3));

        const mat = new THREE.PointsMaterial({
            size: 0.5, // å¢å¤§ç²’å­å°ºå¯¸ï¼Œæå‡äº®åº¦æ„Ÿå—
            vertexColors: true, 
            blending: THREE.AdditiveBlending,
            transparent: true, 
            opacity: 1.0, // å…¨å¼€ä¸é€æ˜åº¦ï¼Œé  AdditiveBlending äº§ç”Ÿé€å æ„Ÿ
            map: dotTexture,
            depthWrite: false
        });

        points = new THREE.Points(geo, mat);
        scene.add(points);

        createSnow(dotTexture);
        createHalo(dotTexture);

        window.addEventListener('pointerdown', e => { isDragging = true; lastX = e.clientX; });
        window.addEventListener('pointermove', e => {
            if (isDragging) {
                targetRotationY += (e.clientX - lastX) * 0.008;
                lastX = e.clientX;
            }
        });
        window.addEventListener('pointerup', () => isDragging = false);
        window.addEventListener('click', () => toggle());
        window.addEventListener('resize', onResize);
        
        animate();
        
    }

    function createData() {
        const color = new THREE.Color();
        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3;
            if (i < COUNT * 0.92) { 
                const t = Math.random();
                const angle = Math.random() * Math.PI * 2;
                const tiers = Math.pow(Math.sin(t * 35), 2) * 0.4 + 0.8;
                const radius = ((1 - t) * 24 * tiers) + (Math.random() - 0.5) * 3;
                tree.pos[i3] = Math.cos(angle) * radius * Math.pow(Math.random(), 0.8);
                tree.pos[i3+1] = t * 48 - 15;
                tree.pos[i3+2] = Math.sin(angle) * radius * Math.pow(Math.random(), 0.8);
                
                const rand = Math.random();
                // æé«˜äº®åº¦æ¯”ä¾‹
                if (rand > 0.85) color.setHex(0xffffff); // 15% çº¯ç™½
                else if (rand > 0.4) color.setHSL(0.92, 0.9, 0.7); // é«˜é¥±å’Œé«˜äº®ç²‰
                else color.setHSL(0.88, 0.6, 0.85); // ææµ…ç²‰
            } else {
                // æ ‘å¹²å¢åŠ ç‚¹äº®åº¦ï¼Œé˜²æ­¢æ­»é»‘
                const h = Math.random() * 8;
                const r = Math.random() * 1.2;
                const a = Math.random() * Math.PI * 2;
                tree.pos[i3] = Math.cos(a) * r;
                tree.pos[i3+1] = -22 + h; 
                tree.pos[i3+2] = Math.sin(a) * r;
                color.setHex(0x5a2d2d); 
            }
            tree.col[i3] = color.r; tree.col[i3+1] = color.g; tree.col[i3+2] = color.b;

            const p = vPoints[i % vPoints.length] || {x:0, y:0};
            text.pos[i3] = p.x + (Math.random()-0.5)*0.5;
            text.pos[i3+1] = p.y + (Math.random()-0.5)*0.5;
            text.pos[i3+2] = (Math.random()-0.5)*4;
            color.setHSL(0.95, 0.8, 0.8); 
            text.col[i3] = color.r; text.col[i3+1] = color.g; text.col[i3+2] = color.b;
        }
    }

    function createHalo(tex) {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(HALO_COUNT * 3);
        for(let i=0; i<HALO_COUNT; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 4 + Math.pow(Math.random(), 0.6) * 55;
            pos[i*3] = Math.cos(angle) * r;
            pos[i*3+1] = -22; 
            pos[i*3+2] = Math.sin(angle) * r;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({
            size: 0.6, 
            color: 0xff69b4, // æ¢æˆæ›´äº®çš„è§å…‰ç²‰
            transparent: true, 
            opacity: 0.5, 
            blending: THREE.AdditiveBlending,
            map: tex, 
            depthWrite: false
        });
        haloPoints = new THREE.Points(geo, mat);
        scene.add(haloPoints);
    }

    function createSnow(tex) {
        const snowGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(1200 * 3);
        for (let i = 0; i < 1200; i++) {
            positions[i*3] = (Math.random() - 0.5) * 200;
            positions[i*3+1] = Math.random() * 150 - 50;
            positions[i*3+2] = (Math.random() - 0.5) * 200;
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        snowPoints = new THREE.Points(snowGeo, new THREE.PointsMaterial({ 
            size: 0.4, color: 0xffffff, transparent: true, opacity: 0.8, map: tex 
        }));
        scene.add(snowPoints);
    }

    function toggle() {
        // åªè¦ç‚¹å‡»å±å¹•è½¬æ¢å½¢æ€ï¼Œå°±å°è¯•æ’­æ”¾éŸ³ä¹
        if (audio && audio.paused) {
            audio.play().catch(e => console.log("è¯·ç¡®ä¿ç›®å½•ä¸‹æœ‰ bgm.mp3"));
    }
        new TWEEN.Tween(state).to({ progress: state.progress < 0.5 ? 1 : 0 }, 2500).easing(TWEEN.Easing.Exponential.InOut).start();
    }

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        const time = Date.now() * 0.001;
        
        currentRotationY += (targetRotationY - currentRotationY) * 0.05;
        if (!isDragging) targetRotationY += AUTO_ROTATION_SPEED;

        const p = state.progress;
        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3;
            mixedPos[i3] = tree.pos[i3] * (1-p) + text.pos[i3] * p;
            mixedPos[i3+1] = tree.pos[i3+1] * (1-p) + text.pos[i3+1] * p;
            mixedPos[i3+2] = tree.pos[i3+2] * (1-p) + text.pos[i3+2] * p;
            mixedCol[i3] = tree.col[i3]*(1-p) + text.col[i3]*p;
            mixedCol[i3+1] = tree.col[i3+1]*(1-p) + text.col[i3+1]*p;
            mixedCol[i3+2] = tree.col[i3+2]*(1-p) + text.col[i3+2]*p;
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
        points.rotation.y = currentRotationY;

        if (haloPoints) {
            const hp = haloPoints.geometry.attributes.position.array;
            for(let i=0; i<HALO_COUNT; i++) {
                const i3 = i * 3;
                const dist = Math.sqrt(hp[i3]**2 + hp[i3+2]**2);
                hp[i3+1] = -22 + Math.sin(time * 1.2 + dist * 0.1) * 2.5; 
            }
            haloPoints.geometry.attributes.position.needsUpdate = true;
            haloPoints.rotation.y -= 0.0003;
        }

        const sp = snowPoints.geometry.attributes.position.array;
        for (let i = 0; i < 1200; i++) {
            sp[i*3+1] -= 0.15;
            if (sp[i*3+1] < -50) sp[i*3+1] = 100;
        }
        snowPoints.geometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    init();
    </script>
</body>
</html>
