<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ„ åœ£è¯å¿«ä¹ ğŸ„</title>
    <style>
        body { margin: 0; background: radial-gradient(circle at center, #1a0510 0%, #050103 100%); overflow: hidden; touch-action: none; font-family: "Microsoft YaHei", sans-serif; user-select: none; }
        .btn-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 12px; align-items: center; z-index: 200; }
        .ui-btn { padding: 10px 24px; font-size: 13px; color: white; background: rgba(255, 255, 255, 0.12); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; cursor: pointer; backdrop-filter: blur(8px); transition: all 0.3s; letter-spacing: 2px; min-width: 120px; }
        /* åˆå§‹åªæ˜¾ç¤ºé‡ç½®æŒ‰é’®ï¼Œè¿”å›æŒ‰é’®åœ¨å¼€å¯åæ˜¾ç¤º */
        #back-gift-btn { display: none; }
        .ui-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.4); }
        .ui-btn:active { transform: scale(0.95); }
        
        #rotate-tip { position: fixed; top: 20px; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.6); font-size: 12px; letter-spacing: 1px; z-index: 100; pointer-events: none; }
        #top-tip { position: fixed; top: 10%; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.6); font-size: 18px; letter-spacing: 3px; z-index: 10; opacity: 0; transition: opacity 1.5s; pointer-events: none; }
        #hint { position: fixed; bottom: 15%; width: 100%; display: flex; flex-direction: column; align-items: center; color: rgba(255, 182, 193, 0.7); letter-spacing: 2px; z-index: 10; font-size: 14px; text-align: center; transition: opacity 0.8s; }
    </style>
</head>
<body>
    <div id="rotate-tip">å·¦é”®æ—‹è½¬ Â· æ»šè½®/åŒæŒ‡ç¼©æ”¾</div>
    <div id="top-tip">ç‚¹å‡»å±å¹• å˜æ¢å½¢æ€</div>
    <div id="hint">â€”â€” ç‚¹å‡»ç¤¼ç‰©ç›’ å¼€å¯æƒŠå–œ â€”â€”<span>â€” by Yuki â€”</span></div>
    
    <div class="btn-container">
        <button id="back-gift-btn" class="ui-btn">è¿”å›ç¤¼ç‰©ç›’</button>
        <button id="reset-btn" class="ui-btn">é‡ç½®è§†è§’</button>
    </div>

    <audio id="bgm" loop src="bgm.mp3"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
    let scene, camera, renderer, points, snowPoints, haloPoints;
    let mixedPos, mixedCol, vPoints = [];
    const COUNT = 38000, HALO_COUNT = 18000;
    const gift = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const tree = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const text = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const state = { transition: 0, explosion: 0, noise: 0 };
    let targetRotationY = 0, currentRotationY = 0, isDragging = false, lastX = 0, hasStarted = false;
    let targetCameraPos = new THREE.Vector3(0, 5, 120), initialPinchDistance = 0, mouse = new THREE.Vector2();

    const resetBtn = document.getElementById('reset-btn');
    const backBtn = document.getElementById('back-gift-btn');
    const hintText = document.getElementById('hint');

    // æ•°æ®å‡†å¤‡ (prepareText, createData é€»è¾‘ä¿æŒä¸å˜)
    function prepareText() {
        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
        canvas.width = 1000; canvas.height = 400; ctx.fillStyle = 'white'; ctx.font = 'bold 120px Arial'; ctx.textAlign = 'center';
        ctx.fillText('MERRY', 500, 150); ctx.fillText('CHRISTMAS', 500, 300);
        const data = ctx.getImageData(0,0,1000,400).data;
        for(let y=0; y<400; y+=2) for(let x=0; x<1000; x+=2) if(data[(y*1000+x)*4]>128) vPoints.push({x:(x-500)*0.12, y:(200-y)*0.12});
    }

    function createData() {
        const color = new THREE.Color();
        const boxSize = 20;
        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3;
            if (i < COUNT * 0.65) { gift.pos[i3] = (Math.random()-0.5)*boxSize; gift.pos[i3+1] = (Math.random()-0.5)*boxSize-10; gift.pos[i3+2] = (Math.random()-0.5)*boxSize; color.setHex(0xd42d68); }
            else if (i < COUNT * 0.8) { const isVert = Math.random() > 0.5; gift.pos[i3] = isVert ? (Math.random()-0.5)*(boxSize+0.6) : (Math.random()-0.5)*4.5; gift.pos[i3+1] = (Math.random()-0.5)*(boxSize+0.6)-10; gift.pos[i3+2] = isVert ? (Math.random()-0.5)*4.5 : (Math.random()-0.5)*(boxSize+0.6); color.setHex(0xffd700); }
            else { const t = Math.random()*6.28, r = (Math.exp(Math.cos(t))-2*Math.cos(4*t)+Math.pow(Math.sin(t/12),5))*2.2; gift.pos[i3]=Math.sin(t)*r; gift.pos[i3+1]=Math.cos(t)*r+3; gift.pos[i3+2]=(Math.random()-0.5)*4; color.setHex(0xfff1b8); }
            gift.col[i3] = color.r; gift.col[i3+1] = color.g; gift.col[i3+2] = color.b;
            if (i < COUNT * 0.92) { const t = Math.random(), a = Math.random()*6.28, r = ((1-t)*24*(Math.pow(Math.sin(t*35),2)*0.4+0.8))+(Math.random()-0.5)*3; tree.pos[i3] = Math.cos(a)*r*Math.pow(Math.random(),0.8); tree.pos[i3+1] = t*48-15; tree.pos[i3+2] = Math.sin(a)*r*Math.pow(Math.random(),0.8); const rr = Math.random(); if(rr>0.85) color.setHex(0xffffff); else if(rr>0.4) color.setHSL(0.92, 0.9, 0.7); else color.setHSL(0.88, 0.6, 0.85); }
            else { tree.pos[i3] = Math.cos(Math.random()*6.28)*Math.random()*1.2; tree.pos[i3+1] = -22+Math.random()*8; tree.pos[i3+2] = Math.sin(Math.random()*6.28)*Math.random()*1.2; color.setHex(0x5a2d2d); }
            tree.col[i3] = color.r; tree.col[i3+1] = color.g; tree.col[i3+2] = color.b;
            const p = vPoints[i % vPoints.length] || {x:0, y:0}; text.pos[i3] = p.x+(Math.random()-0.5)*0.5; text.pos[i3+1] = p.y+(Math.random()-0.5)*0.5; text.pos[i3+2] = (Math.random()-0.5)*4; color.setHSL(0.95, 0.8, 0.8); text.col[i3] = color.r; text.col[i3+1] = color.g; text.col[i3+2] = color.b;
        }
    }

    function smoothZoomAt(px, py, delta) {
        mouse.x = (px/window.innerWidth)*2-1; mouse.y = -(py/window.innerHeight)*2+1;
        const v = new THREE.Vector3(mouse.x, mouse.y, 0.5); v.unproject(camera);
        const dir = v.sub(camera.position).normalize();
        const move = -delta * (targetCameraPos.length() * 0.0008); 
        const next = targetCameraPos.clone().add(dir.multiplyScalar(move));
        if (next.z > 15 && next.z < 260) targetCameraPos.copy(next);
    }

    function init() {
        prepareText(); createData();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
        camera.position.set(0, 5, 120); targetCameraPos.copy(camera.position);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const tex = (function(){ const c = document.createElement('canvas'); c.width=64; c.height=64; const ctx=c.getContext('2d'); const g = ctx.createRadialGradient(32,32,0,32,32,32); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,64,64); return new THREE.CanvasTexture(c); })();
        points = new THREE.Points(new THREE.BufferGeometry(), new THREE.PointsMaterial({ size: 0.55, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, map: tex, depthWrite: false }));
        mixedPos = new Float32Array(gift.pos); mixedCol = new Float32Array(gift.col);
        points.geometry.setAttribute('position', new THREE.BufferAttribute(mixedPos, 3));
        points.geometry.setAttribute('color', new THREE.BufferAttribute(mixedCol, 3));
        scene.add(points);

        snowPoints = (function(){ const g = new THREE.BufferGeometry(); const p = new Float32Array(1500*3); for(let i=0;i<1500;i++){ p[i*3]=(Math.random()-0.5)*250; p[i*3+1]=Math.random()*150-50; p[i*3+2]=(Math.random()-0.5)*250; } g.setAttribute('position', new THREE.BufferAttribute(p,3)); const s = new THREE.Points(g, new THREE.PointsMaterial({size:0.4, color:0xffffff, transparent:true, opacity:0.8, map:tex})); scene.add(s); return s; })();
        
        haloPoints = (function(){ const hGeo = new THREE.BufferGeometry(); const hP = new Float32Array(HALO_COUNT*3); for(let i=0;i<HALO_COUNT;i++){ const a=Math.random()*Math.PI*2, r=4+Math.pow(Math.random(),0.6)*55; hP[i*3]=Math.cos(a)*r; hP[i*3+1]=-22; hP[i*3+2]=Math.sin(a)*r; } hGeo.setAttribute('position', new THREE.BufferAttribute(hP,3)); const h = new THREE.Points(hGeo, new THREE.PointsMaterial({size:0.6, color:0xff69b4, transparent:true, opacity:0.5, blending: THREE.AdditiveBlending, map:tex, depthWrite: false})); scene.add(h); return h; })();

        // äº¤äº’ç›‘å¬
        window.addEventListener('mousedown', e => { if(e.button===0) { isDragging = true; lastX = e.clientX; } });
        window.addEventListener('mousemove', e => { if(isDragging) { targetRotationY += (e.clientX - lastX)*0.008; lastX = e.clientX; } });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('wheel', e => { e.preventDefault(); smoothZoomAt(e.clientX, e.clientY, e.deltaY*0.7); }, {passive:false});
        window.addEventListener('touchstart', e => { if(e.touches.length===1){ isDragging=true; lastX=e.touches[0].clientX; } else if(e.touches.length===2){ isDragging=false; initialPinchDistance=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY); } }, {passive:false});
        window.addEventListener('touchmove', e => { if(e.touches.length===1 && isDragging){ targetRotationY += (e.touches[0].clientX - lastX)*0.008; lastX=e.touches[0].clientX; } else if(e.touches.length===2){ const d = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY); smoothZoomAt((e.touches[0].clientX+e.touches[1].clientX)/2, (e.touches[0].clientY+e.touches[1].clientY)/2, (initialPinchDistance/d-1)*350); initialPinchDistance=d; } }, {passive:false});

        window.addEventListener('click', e => { if(!e.target.classList.contains('ui-btn')) handleInteraction(); });

        // é‡ç½®æŒ‰é’®ï¼šåªç®¡è§†è§’è·ç¦»ï¼Œä¸ç®¡æ—‹è½¬
        resetBtn.addEventListener('click', e => { 
            e.stopPropagation(); 
            const dist = hasStarted ? 85 : 120; // å¼€å¯åé‡ç½®åˆ°85ï¼Œæ²¡å¼€å¯é‡ç½®åˆ°120
            new TWEEN.Tween(targetCameraPos).to({x:0, y:5, z:dist}, 1000).easing(TWEEN.Easing.Cubic.Out).start();
            // ä¸å†æ‰§è¡Œ targetRotationY = 0;
        });

        // è¿”å›ç¤¼ç‰©ç›’æŒ‰é’®
        backBtn.addEventListener('click', e => {
            e.stopPropagation();
            new TWEEN.Tween(state).to({transition: 0}, 2000).easing(TWEEN.Easing.Exponential.InOut).start();
            new TWEEN.Tween(targetCameraPos).to({x:0, y:5, z:120}, 2000).easing(TWEEN.Easing.Cubic.InOut).start();
            // targetRotationY = 0; // å¯é€‰ï¼šè¿”å›æ—¶æ˜¯å¦é‡ç½®æ—‹è½¬ã€‚è¿™é‡Œæˆ‘ä¿ç•™äº†æ—‹è½¬ã€‚
            backBtn.style.display = 'none';
            hintText.style.opacity = 1;
            hasStarted = false;
        });

        animate();
    }

    function handleInteraction() {
        if (!hasStarted) {
            hasStarted = true; hintText.style.opacity = 0; 
            backBtn.style.display = 'block';
            document.getElementById('bgm').play().catch(()=>{});
            new TWEEN.Tween(state).to({explosion:2, noise:50}, 700).easing(TWEEN.Easing.Quadratic.Out).chain(new TWEEN.Tween(state).to({transition:1, explosion:0, noise:0}, 3000).easing(TWEEN.Easing.Exponential.InOut)).start();
            setTimeout(()=> document.getElementById('top-tip').style.opacity=1, 800);
            new TWEEN.Tween(targetCameraPos).to({z:85}, 3000).easing(TWEEN.Easing.Cubic.InOut).start();
        } else {
            new TWEEN.Tween(state).to({transition: state.transition < 1.5 ? 2 : 1}, 2500).easing(TWEEN.Easing.Exponential.InOut).start();
        }
    }

    function animate() {
        requestAnimationFrame(animate); TWEEN.update();
        camera.position.lerp(targetCameraPos, 0.1);
        currentRotationY += (targetRotationY - currentRotationY)*0.05;
        if(!isDragging) targetRotationY += 0.0012;

        const {transition:t, explosion:e, noise:n} = state;
        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3; let tx, ty, tz, tr, tg, tb;
            if (t <= 1) { tx = gift.pos[i3]*(1-t)+tree.pos[i3]*t; ty = gift.pos[i3+1]*(1-t)+tree.pos[i3+1]*t; tz = gift.pos[i3+2]*(1-t)+tree.pos[i3+2]*t; tr = gift.col[i3]*(1-t)+tree.col[i3]*t; tg = gift.col[i3+1]*(1-t)+tree.col[i3+1]*t; tb = gift.col[i3+2]*(1-t)+tree.col[i3+2]*t; }
            else { const t2 = t-1; tx = tree.pos[i3]*(1-t2)+text.pos[i3]*t2; ty = tree.pos[i3+1]*(1-t2)+text.pos[i3+1]*t2; tz = tree.pos[i3+2]*(1-t2)+text.pos[i3+2]*t2; tr = tree.col[i3]*(1-t2)+text.col[i3]*t2; tg = tree.col[i3+1]*(1-t2)+text.col[i3+1]*t2; tb = tree.col[i3+2]*(1-t2)+text.col[i3+2]*t2; }
            const ang = i*0.137, s = 75*e;
            mixedPos[i3] = tx + Math.cos(ang)*s + (Math.random()-0.5)*n*e;
            mixedPos[i3+1] = ty + Math.sin(ang*0.5)*s + (Math.random()-0.5)*n*e;
            mixedPos[i3+2] = tz + Math.sin(ang)*s + (Math.random()-0.5)*n*e;
            mixedCol[i3] = tr; mixedCol[i3+1] = tg; mixedCol[i3+2] = tb;
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
        points.rotation.y = currentRotationY;

        if (haloPoints) {
            const hp = haloPoints.geometry.attributes.position.array; const time = Date.now() * 0.001;
            for(let i=0; i<HALO_COUNT; i++) { const i3 = i * 3; const d = Math.sqrt(hp[i3]**2 + hp[i3+2]**2); hp[i3+1] = -22 + Math.sin(time * 1.5 + d * 0.15) * 2.2; }
            haloPoints.geometry.attributes.position.needsUpdate = true;
            haloPoints.rotation.y -= 0.0005;
        }
        const sp = snowPoints.geometry.attributes.position.array;
        for (let i = 0; i < 1500; i++) { sp[i*3+1] -= 0.15; if (sp[i*3+1] < -60) sp[i*3+1] = 100; }
        snowPoints.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    init();
    </script>
</body>
</html>
