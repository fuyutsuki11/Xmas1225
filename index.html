<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ„ åœ£è¯å¿«ä¹ ğŸ„</title>
    <style>
        body { 
            margin: 0; background: radial-gradient(circle at center, #1a0510 0%, #050103 100%); 
            overflow: hidden; touch-action: none; font-family: "Microsoft YaHei", sans-serif;
            user-select: none; /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰ä¸­æ–‡å­— */
        }
        #rotate-tip {
            position: fixed; top: 30px; left: 0; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.8); font-size: 14px; letter-spacing: 2px;
            z-index: 100; pointer-events: none; animation: pulse 2s infinite ease-in-out;
        }
        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 0.9; } 100% { opacity: 0.4; } }
        #top-tip {
            position: fixed; top: 10%; left: 0; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.6); font-size: 18px; letter-spacing: 3px; 
            z-index: 10; opacity: 0; transition: opacity 1.5s; pointer-events: none;
        }
        #hint {
            position: fixed; bottom: 12%; left: 0; width: 100%; display: flex;
            flex-direction: column; align-items: center; color: rgba(255, 182, 193, 0.7); 
            letter-spacing: 2px; z-index: 10; font-size: 14px; text-align: center; line-height: 2;
            transition: opacity 0.8s;
        }
        #hint span { font-size: 10px; opacity: 0.8; letter-spacing: 2px; margin-top: 4px; }
    </style>
</head>
<body>
    <div id="rotate-tip">å•æŒ‡/é¼ æ ‡å·¦é”®æ—‹è½¬ Â· æ»šè½®/åŒæŒ‡ç¼©æ”¾</div>
    <div id="top-tip"> ç‚¹å‡»å±å¹• å˜æ¢å½¢æ€ </div>
    <div id="hint">â€”â€” ç‚¹å‡»ç¤¼ç‰©ç›’ å¼€å¯æƒŠå–œ â€”â€”<span>â€” by Yuki â€”</span></div>

    <audio id="bgm" loop src="bgm.mp3"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
    const audio = document.getElementById('bgm');
    const hintText = document.getElementById('hint');
    const topTip = document.getElementById('top-tip');
    
    let scene, camera, renderer, points, snowPoints, haloPoints;
    let mixedPos, mixedCol, vPoints = [];
    const COUNT = 38000; 
    const HALO_COUNT = 18000;
    
    const gift = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const tree = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const text = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    
    const state = { transition: 0, explosion: 0, noise: 0 }; 
    let targetRotationY = 0, currentRotationY = 0, isDragging = false, lastX = 0, hasStarted = false;

    // --- ä¸æ»‘ç¼©æ”¾æ ¸å¿ƒå˜é‡ ---
    const mouse = new THREE.Vector2();
    let targetCameraPos = new THREE.Vector3(0, 5, 100);
    let initialPinchDistance = 0;
    const lerpFactor = 0.1;

    function fadeInAudio(audioObj, maxVolume = 0.3, duration = 3000) {
        audioObj.volume = 0;
        audioObj.play().catch(e => {});
        let startTime = Date.now();
        let interval = setInterval(() => {
            let progress = (Date.now() - startTime) / duration;
            if (progress >= 1) { audioObj.volume = maxVolume; clearInterval(interval); }
            else { audioObj.volume = maxVolume * progress; }
        }, 50);
    }

    function createCircleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
        gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.6, 'rgba(255,255,255,0.1)'); 
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
    }

    function prepareText() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1000; canvas.height = 400;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 120px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('MERRY', 500, 150);
        ctx.fillText('CHRISTMAS', 500, 300);
        const data = ctx.getImageData(0,0,1000,400).data;
        for(let y=0; y<400; y+=2) {
            for(let x=0; x<1000; x+=2) {
                if(data[(y*1000+x)*4] > 128) {
                    vPoints.push({x:(x-500)*0.12, y:(200-y)*0.12});
                }
            }
        }
    }

    function createData() {
        const color = new THREE.Color();
        const boxSize = 20;
        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3;
            // ç¤¼ç‰©ç›’
            if (i < COUNT * 0.65) { 
                gift.pos[i3] = (Math.random() - 0.5) * boxSize;
                gift.pos[i3+1] = (Math.random() - 0.5) * boxSize - 10;
                gift.pos[i3+2] = (Math.random() - 0.5) * boxSize;
                color.setHex(0xd42d68);
            } else if (i < COUNT * 0.8) {
                const isVert = Math.random() > 0.5;
                gift.pos[i3] = isVert ? (Math.random() - 0.5) * (boxSize + 0.6) : (Math.random() - 0.5) * 4.5;
                gift.pos[i3+1] = (Math.random() - 0.5) * (boxSize + 0.6) - 10;
                gift.pos[i3+2] = isVert ? (Math.random() - 0.5) * 4.5 : (Math.random() - 0.5) * (boxSize + 0.6);
                color.setHex(0xffd700);
            } else {
                const t = Math.random() * Math.PI * 2;
                const r = (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin(t / 12), 5)) * 2.2;
                const x = Math.sin(t) * r; const y = Math.cos(t) * r;
                gift.pos[i3] = x; gift.pos[i3+1] = y + 3;
                gift.pos[i3+2] = (Math.random() - 0.5) * 4 + Math.abs(x) * 0.3;
                color.setHex(0xfff1b8); 
            }
            gift.col[i3] = color.r; gift.col[i3+1] = color.g; gift.col[i3+2] = color.b;
            // åœ£è¯æ ‘
            if (i < COUNT * 0.92) { 
                const t = Math.random(); const angle = Math.random() * Math.PI * 2;
                const tiers = Math.pow(Math.sin(t * 35), 2) * 0.4 + 0.8;
                const radius = ((1 - t) * 24 * tiers) + (Math.random() - 0.5) * 3;
                tree.pos[i3] = Math.cos(angle) * radius * Math.pow(Math.random(), 0.8);
                tree.pos[i3+1] = t * 48 - 15;
                tree.pos[i3+2] = Math.sin(angle) * radius * Math.pow(Math.random(), 0.8);
                const rr = Math.random();
                if (rr > 0.85) color.setHex(0xffffff);
                else if (rr > 0.4) color.setHSL(0.92, 0.9, 0.7);
                else color.setHSL(0.88, 0.6, 0.85);
            } else {
                tree.pos[i3] = Math.cos(Math.random()*6.28) * Math.random()*1.2;
                tree.pos[i3+1] = -22 + Math.random()*8; 
                tree.pos[i3+2] = Math.sin(Math.random()*6.28) * Math.random()*1.2;
                color.setHex(0x5a2d2d); 
            }
            tree.col[i3] = color.r; tree.col[i3+1] = color.g; tree.col[i3+2] = color.b;
            // æ–‡å­—
            const p = vPoints[i % vPoints.length] || {x:0, y:0};
            text.pos[i3] = p.x + (Math.random()-0.5)*0.5;
            text.pos[i3+1] = p.y + (Math.random()-0.5)*0.5;
            text.pos[i3+2] = (Math.random()-0.5)*4;
            color.setHSL(0.95, 0.8, 0.8); 
            text.col[i3] = color.r; text.col[i3+1] = color.g; text.col[i3+2] = color.b;
        }
    }

    function getDist(t1, t2) {
        return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
    }

    // --- æ ¸å¿ƒæŒ‡å‘æ€§ç¼©æ”¾é€»è¾‘ ---
    function smoothZoomAt(pointX, pointY, delta) {
        mouse.x = (pointX / window.innerWidth) * 2 - 1;
        mouse.y = -(pointY / window.innerHeight) * 2 + 1;
        const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const dist = targetCameraPos.length();
        const moveAmount = -delta * (dist * 0.0008); 
        const nextPos = targetCameraPos.clone().add(dir.multiplyScalar(moveAmount));
        if (nextPos.z > 15 && nextPos.z < 260) targetCameraPos.copy(nextPos);
    }

    function init() {
        prepareText();
        const dotTexture = createCircleTexture();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
        camera.position.set(0, 5, 100);
        targetCameraPos.copy(camera.position);
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        createData();
        const geo = new THREE.BufferGeometry();
        mixedPos = new Float32Array(gift.pos);
        mixedCol = new Float32Array(gift.col);
        geo.setAttribute('position', new THREE.BufferAttribute(mixedPos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(mixedCol, 3));
        points = new THREE.Points(geo, new THREE.PointsMaterial({
            size: 0.55, vertexColors: true, blending: THREE.AdditiveBlending,
            transparent: true, opacity: 1.0, map: dotTexture, depthWrite: false
        }));
        scene.add(points);
        createSnow(dotTexture); createHalo(dotTexture);

        // --- å®Œæ•´äº¤äº’ç›‘å¬ (PC é¼ æ ‡ + ç§»åŠ¨ç«¯è§¦æ‘¸) ---

        // PC é¼ æ ‡æ—‹è½¬é€»è¾‘
        window.addEventListener('mousedown', e => {
            isDragging = true; lastX = e.clientX;
        });
        window.addEventListener('mousemove', e => {
            if (isDragging) {
                targetRotationY += (e.clientX - lastX) * 0.008;
                lastX = e.clientX;
            }
        });
        window.addEventListener('mouseup', () => { isDragging = false; });

        // PC æ»šè½®ç¼©æ”¾
        window.addEventListener('wheel', e => {
            e.preventDefault();
            smoothZoomAt(e.clientX, e.clientY, e.deltaY * 0.7);
        }, { passive: false });

        // ç§»åŠ¨ç«¯è§¦æ‘¸é€»è¾‘ (æ—‹è½¬ + åŒæŒ‡ç¼©æ”¾)
        window.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                isDragging = true; lastX = e.touches[0].clientX;
            } else if (e.touches.length === 2) {
                isDragging = false;
                initialPinchDistance = getDist(e.touches[0], e.touches[1]);
            }
        }, { passive: false });

        window.addEventListener('touchmove', e => {
            if (e.touches.length === 1 && isDragging) {
                targetRotationY += (e.touches[0].clientX - lastX) * 0.008;
                lastX = e.touches[0].clientX;
            } else if (e.touches.length === 2) {
                const curDist = getDist(e.touches[0], e.touches[1]);
                const ratio = initialPinchDistance / curDist;
                const delta = (ratio - 1) * 350; 
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                smoothZoomAt(midX, midY, delta);
                initialPinchDistance = curDist;
            }
        }, { passive: false });

        window.addEventListener('touchend', () => { isDragging = false; });

        // åŒå‡»é‡ç½®
        window.addEventListener('dblclick', () => {
            targetCameraPos.set(0, 5, 85);
            targetRotationY = 0;
        });

        window.addEventListener('click', handleInteraction);
        window.addEventListener('resize', onResize);
        animate();
    }

    function handleInteraction() {
        if (!hasStarted) {
            hasStarted = true; hintText.style.opacity = 0; 
            if (audio) fadeInAudio(audio, 0.3, 3000);
            new TWEEN.Tween(state).to({ explosion: 2.0, noise: 50 }, 700).easing(TWEEN.Easing.Quadratic.Out)
                .chain(new TWEEN.Tween(state).to({ transition: 1, explosion: 0, noise: 0 }, 3000).easing(TWEEN.Easing.Exponential.InOut)).start();
            setTimeout(() => { topTip.style.opacity = 1; }, 800); 
            new TWEEN.Tween(camera.position).to({ z: 85 }, 3000).easing(TWEEN.Easing.Cubic.InOut)
                .onUpdate(() => targetCameraPos.copy(camera.position)).start();
        } else {
            const next = state.transition < 1.5 ? 2 : 1;
            new TWEEN.Tween(state).to({ transition: next }, 2500).easing(TWEEN.Easing.Exponential.InOut).start();
        }
    }

    // (èƒŒæ™¯ç²’å­åˆ›å»ºé€»è¾‘ halo/snow ä¿æŒä¸å˜...)
    function createHalo(tex) {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(HALO_COUNT * 3);
        for(let i=0; i<HALO_COUNT; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 4 + Math.pow(Math.random(), 0.6) * 55;
            pos[i*3] = Math.cos(angle) * r; pos[i*3+1] = -22; pos[i*3+2] = Math.sin(angle) * r;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        haloPoints = new THREE.Points(geo, new THREE.PointsMaterial({
            size: 0.6, color: 0xff69b4, transparent: true, opacity: 0.5, 
            blending: THREE.AdditiveBlending, map: tex, depthWrite: false
        }));
        scene.add(haloPoints);
    }

    function createSnow(tex) {
        const snowGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(1500 * 3);
        for (let i = 0; i < 1500; i++) {
            positions[i*3] = (Math.random() - 0.5) * 250;
            positions[i*3+1] = Math.random() * 150 - 50;
            positions[i*3+2] = (Math.random() - 0.5) * 250;
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        snowPoints = new THREE.Points(snowGeo, new THREE.PointsMaterial({ size: 0.4, color: 0xffffff, transparent: true, opacity: 0.8, map: tex }));
        scene.add(snowPoints);
    }

    function animate() {
        requestAnimationFrame(animate); 
        TWEEN.update();
        camera.position.lerp(targetCameraPos, lerpFactor);
        const time = Date.now() * 0.001;
        currentRotationY += (targetRotationY - currentRotationY) * 0.05;
        if (!isDragging) targetRotationY += 0.0012;
        
        const t = state.transition, e = state.explosion, n = state.noise;
        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3;
            let tx, ty, tz, tr, tg, tb;
            if (t <= 1) {
                tx = gift.pos[i3] * (1-t) + tree.pos[i3] * t;
                ty = gift.pos[i3+1] * (1-t) + tree.pos[i3+1] * t;
                tz = gift.pos[i3+2] * (1-t) + tree.pos[i3+2] * t;
                tr = gift.col[i3] * (1-t) + tree.col[i3] * t;
                tg = gift.col[i3+1] * (1-t) + tree.col[i3+1] * t;
                tb = gift.col[i3+2] * (1-t) + tree.col[i3+2] * t;
            } else {
                const t2 = t - 1;
                tx = tree.pos[i3] * (1-t2) + text.pos[i3] * t2;
                ty = tree.pos[i3+1] * (1-t2) + text.pos[i3+1] * t2;
                tz = tree.pos[i3+2] * (1-t2) + text.pos[i3+2] * t2;
                tr = tree.col[i3] * (1-t2) + text.col[i3] * t2;
                tg = tree.col[i3+1] * (1-t2) + text.col[i3+1] * t2;
                tb = tree.col[i3+2] * (1-t2) + text.col[i3+2] * t2;
            }
            const angle = i * 0.137; const spread = 75 * e;
            mixedPos[i3] = tx + Math.cos(angle) * spread + (Math.random()-0.5) * n * e;
            mixedPos[i3+1] = ty + Math.sin(angle * 0.5) * spread + (Math.random()-0.5) * n * e;
            mixedPos[i3+2] = tz + Math.sin(angle) * spread + (Math.random()-0.5) * n * e;
            mixedCol[i3] = tr; mixedCol[i3+1] = tg; mixedCol[i3+2] = tb;
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
        points.rotation.y = currentRotationY;

        if (haloPoints) {
            const hp = haloPoints.geometry.attributes.position.array;
            for(let i=0; i<HALO_COUNT; i++) {
                const i3 = i * 3; const dist = Math.sqrt(hp[i3]**2 + hp[i3+2]**2);
                hp[i3+1] = -22 + Math.sin(time * 1.2 + dist * 0.1) * 2.5; 
            }
            haloPoints.geometry.attributes.position.needsUpdate = true;
            haloPoints.rotation.y -= 0.0003;
        }
        const sp = snowPoints.geometry.attributes.position.array;
        for (let i = 0; i < 1500; i++) { sp[i*3+1] -= 0.15; if (sp[i*3+1] < -60) sp[i*3+1] = 100; }
        snowPoints.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    init();
    </script>
</body>
</html>
