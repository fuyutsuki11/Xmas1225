<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ„ åœ£è¯å¿«ä¹ ğŸ„</title>
    <style>
        body { margin: 0; background: radial-gradient(circle at center, #1a0510 0%, #050103 100%); overflow: hidden; touch-action: none; font-family: "Microsoft YaHei", sans-serif; user-select: none; }
        .btn-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 12px; align-items: center; z-index: 200; }
        .ui-btn { padding: 10px 24px; font-size: 13px; color: white; background: rgba(255, 255, 255, 0.12); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; cursor: pointer; backdrop-filter: blur(8px); transition: all 0.3s; letter-spacing: 2px; min-width: 120px; }
        #back-gift-btn { display: none; }
        .ui-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.4); }
        #rotate-tip { position: fixed; top: 20px; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.6); font-size: 18px; z-index: 100; pointer-events: none; }
        #top-tip { position: fixed; top: 10%; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.6); font-size: 18px; letter-spacing: 3px; z-index: 10; opacity: 0; transition: opacity 2s; pointer-events: none; }
        #hint { position: fixed; bottom: 15%; width: 100%; display: flex; flex-direction: column; align-items: center; color: rgba(255, 182, 193, 0.7); letter-spacing: 2px; z-index: 10; font-size: 14px; text-align: center; transition: opacity 0.8s; }
    </style>
</head>
<body>
    <div id="rotate-tip">æŒ‰ä½æ—‹è½¬ Â· æ»šè½®/åŒæŒ‡ç¼©æ”¾</div>
    <div id="top-tip">ç‚¹å‡»å±å¹• å˜æ¢å½¢æ€</div>
    <div id="hint">â€”â€” ç‚¹å‡»ç¤¼ç‰©ç›’ å¼€å¯æƒŠå–œ â€”â€”<span>â€” by Yuki â€”</span></div>
    
    <div class="btn-container">
        <button id="back-gift-btn" class="ui-btn">è¿”å›ç¤¼ç‰©ç›’</button>
        <button id="reset-btn" class="ui-btn">é‡ç½®è§†è§’</button>
    </div>
    <audio id="bgm" loop src="bgm.mp3"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
    let scene, camera, renderer, points, snowPoints, haloPoints;
    let mixedPos, mixedCol, vPoints = [];
    const COUNT = 38000, HALO_COUNT = 18000;
    const gift = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const tree = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const text = { pos: new Float32Array(COUNT * 3), col: new Float32Array(COUNT * 3) };
    const state = { transition: 0, bloom: 0, drift: 0, gravity: 0, shimmer: 0 };

    let isDragging = false, hasStarted = false;
    let lastX = 0, lastY = 0, startX = 0, startY = 0;
    let initialPinchDist = 0;
    const mouse = new THREE.Vector2();
    const colorTool = new THREE.Color();

    function prepareText() {
        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
        canvas.width = 1000; canvas.height = 400; ctx.fillStyle = 'white'; ctx.font = 'bold 120px Arial'; ctx.textAlign = 'center';
        ctx.fillText('MERRY', 500, 150); ctx.fillText('CHRISTMAS', 500, 300);
        const data = ctx.getImageData(0,0,1000,400).data;
        for(let y=0; y<400; y+=4) for(let x=0; x<1000; x+=4) if(data[(y*1000+x)*4]>128) vPoints.push({x:(x-500)*0.15, y:(200-y)*0.15});
    }

    function createData() {
        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3;
            if (i < COUNT * 0.75) {
                const side = Math.floor(Math.random() * 6);
                let x, y, z;
                const r = 10;
                const u = (Math.random() - 0.5) * 2 * r;
                const v = (Math.random() - 0.5) * 2 * r;
                if(side===0){x=r; y=u; z=v} else if(side===1){x=-r; y=u; z=v}
                else if(side===2){y=r; x=u; z=v} else if(side===3){y=-r; x=u; z=v}
                else if(side===4){z=r; x=u; y=v} else {z=-r; x=u; y=v}
                gift.pos[i3]=x; gift.pos[i3+1]=y-10; gift.pos[i3+2]=z;
                colorTool.setHex(0xd42d68);
            } else if (i < COUNT * 0.9) {
                const axis = Math.random() > 0.5 ? 'x' : 'z';
                const r = 10.2;
                gift.pos[i3] = axis === 'x' ? (Math.random()-0.5)*20.4 : (Math.random()>0.5?2.5:-2.5);
                gift.pos[i3+1] = (Math.random()-0.5)*20.4 - 10;
                gift.pos[i3+2] = axis === 'z' ? (Math.random()-0.5)*20.4 : (Math.random()>0.5?2.5:-2.5);
                colorTool.setHex(0xffd700);
            } else {
                const t = Math.random()*6.28, rad = (Math.exp(Math.cos(t)) - 2*Math.cos(4*t) + Math.pow(Math.sin(t/12),5))*2.2;
                gift.pos[i3] = Math.sin(t)*rad; gift.pos[i3+1] = Math.cos(t)*rad + 2; gift.pos[i3+2] = (Math.random()-0.5)*4;
                colorTool.setHex(0xfff1b8);
            }
            gift.col[i3]=colorTool.r; gift.col[i3+1]=colorTool.g; gift.col[i3+2]=colorTool.b;

            const t = Math.random(), a = Math.random()*6.28, r_tree = ((1-t)*24*(Math.pow(Math.sin(t*35),2)*0.4+0.8))+(Math.random()-0.5)*3;
            if (i < COUNT * 0.92) {
                tree.pos[i3]=Math.cos(a)*r_tree*Math.pow(Math.random(),0.8); tree.pos[i3+1]=t*48-15; tree.pos[i3+2]=Math.sin(a)*r_tree*Math.pow(Math.random(),0.8);
                const rand=Math.random(); if(rand>0.88)colorTool.setHex(0xffffff); else if(rand>0.6)colorTool.setHex(0xffd700); else colorTool.setHSL(0.35,0.8,0.25+Math.random()*0.2);
            } else {
                tree.pos[i3]=(Math.random()-0.5)*3; tree.pos[i3+1]=-22+Math.random()*8; tree.pos[i3+2]=(Math.random()-0.5)*3; colorTool.setHex(0x5a2d2d);
            }
            tree.col[i3]=colorTool.r; tree.col[i3+1]=colorTool.g; tree.col[i3+2]=colorTool.b;

            const p = vPoints[i % vPoints.length] || {x:0, y:0};
            text.pos[i3]=p.x; text.pos[i3+1]=p.y; text.pos[i3+2]=(Math.random()-0.5)*5;
        }
    }

    function init() {
        prepareText(); createData();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
        camera.position.set(0, 5, 120); 
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const tex = (function(){ const c=document.createElement('canvas'); c.width=64; c.height=64; const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(32,32,0,32,32,32); g.addColorStop(0,'white'); g.addColorStop(0.5,'rgba(255,255,255,0.8)'); g.addColorStop(1,'transparent'); ctx.fillStyle=g; ctx.fillRect(0,0,64,64); return new THREE.CanvasTexture(c); })();

        points = new THREE.Points(new THREE.BufferGeometry(), new THREE.PointsMaterial({ size: 0.7, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, map: tex, depthWrite: false }));
        mixedPos = new Float32Array(gift.pos); mixedCol = new Float32Array(gift.col);
        points.geometry.setAttribute('position', new THREE.BufferAttribute(mixedPos, 3));
        points.geometry.setAttribute('color', new THREE.BufferAttribute(mixedCol, 3));
        scene.add(points);

        snowPoints = (function(){ const g=new THREE.BufferGeometry(); const p=new Float32Array(1500*3); for(let i=0;i<1500;i++){ p[i*3]=(Math.random()-0.5)*300; p[i*3+1]=Math.random()*200-50; p[i*3+2]=(Math.random()-0.5)*300; } g.setAttribute('position', new THREE.BufferAttribute(p,3)); return new THREE.Points(g, new THREE.PointsMaterial({size:0.4, color:0xffffff, transparent:true, opacity:0.6, map:tex})); })();
        scene.add(snowPoints);

        haloPoints = (function(){ const g=new THREE.BufferGeometry(); const p=new Float32Array(HALO_COUNT*3); for(let i=0;i<HALO_COUNT;i++){ const a=Math.random()*6.28, r=4+Math.pow(Math.random(),0.6)*55; p[i*3]=Math.cos(a)*r; p[i*3+1]=-22; p[i*3+2]=Math.sin(a)*r; } g.setAttribute('position', new THREE.BufferAttribute(p,3)); return new THREE.Points(g, new THREE.PointsMaterial({size:0.6, color:0xff69b4, transparent:true, opacity:0.4, blending: THREE.AdditiveBlending, map:tex, depthWrite: false})); })();
        scene.add(haloPoints);

        // --- é¼ æ ‡äº‹ä»¶ (ä¿æŒä¸å˜) ---
        window.addEventListener('mousedown', e => { if(e.button === 0) { isDragging = true; startX = e.clientX; startY = e.clientY; lastX = e.clientX; lastY = e.clientY; } });
        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if(isDragging) {
                points.rotation.y += (e.clientX - lastX) * 0.005;
                points.rotation.x += (e.clientY - lastY) * 0.005;
                lastX = e.clientX; lastY = e.clientY;
            }
        });
        window.addEventListener('mouseup', e => {
            if(isDragging) {
                const deltaMove = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
                if(deltaMove < 5 && !e.target.classList.contains('ui-btn')) handleInteraction();
                isDragging = false;
            }
        });

        // --- æ ¸å¿ƒä¿®æ­£ï¼šç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶å¤„ç† ---
        window.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                isDragging = true;
                startX = e.touches[0].clientX; startY = e.touches[0].clientY;
                lastX = startX; lastY = startY;
            } else if (e.touches.length === 2) {
                isDragging = false; // åŒæŒ‡ç¼©æ”¾æ—¶åœæ­¢æ—‹è½¬
                initialPinchDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            }
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            if (e.touches.length === 1 && isDragging) {
                // å•æŒ‡æ»‘åŠ¨ï¼šæ‰§è¡Œæ—‹è½¬
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                points.rotation.y += (currentX - lastX) * 0.008;
                points.rotation.x += (currentY - lastY) * 0.008;
                lastX = currentX; lastY = currentY;
            } else if (e.touches.length === 2) {
                // åŒæŒ‡æåˆï¼šæ‰§è¡Œç¼©æ”¾
                e.preventDefault(); 
                const currentDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                const delta = (currentDist - initialPinchDist) * 0.4;
                camera.position.z -= delta;
                initialPinchDist = currentDist;
                const dist = camera.position.length();
                if(dist < 15) camera.position.setLength(15);
                if(dist > 350) camera.position.setLength(350);
            }
        }, {passive: false});

        window.addEventListener('touchend', e => {
            if (isDragging && e.touches.length === 0) {
                const deltaMove = Math.sqrt(Math.pow(lastX - startX, 2) + Math.pow(lastY - startY, 2));
                // å¦‚æœæ»‘åŠ¨è·ç¦»å¾ˆçŸ­ï¼Œåˆ¤å®šä¸ºç‚¹å‡»ï¼ˆå¼€å¯ç¤¼ç‰©ç›’ï¼‰
                if(deltaMove < 10 && !e.target.classList.contains('ui-btn')) handleInteraction();
                isDragging = false;
            }
        });

        window.addEventListener('wheel', e => {
            e.preventDefault();
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const step = -e.deltaY * 0.05; 
            camera.position.addScaledVector(dir, step);
            const dist = camera.position.length();
            if(dist < 15) camera.position.setLength(15);
            if(dist > 350) camera.position.setLength(350);
        }, {passive:false});

        document.getElementById('reset-btn').addEventListener('click', e => {
            e.stopPropagation();
            new TWEEN.Tween(camera.position).to({x:0, y:5, z: hasStarted ? 85 : 120}, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
            new TWEEN.Tween(points.rotation).to({x:0, y:0}, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        });

        document.getElementById('back-gift-btn').addEventListener('click', e => {
            e.stopPropagation();
            new TWEEN.Tween(state).to({transition: 0, bloom: 0, gravity: 0, drift: 0, shimmer: 0}, 1500).easing(TWEEN.Easing.Exponential.InOut).start();
            new TWEEN.Tween(camera.position).to({x:0, y:5, z: 120}, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
            new TWEEN.Tween(points.rotation).to({x:0, y:0}, 1500).start();
            document.getElementById('back-gift-btn').style.display='none'; document.getElementById('hint').style.opacity=1; hasStarted=false;
        });

        animate();
    }

    function handleInteraction() {
        if (!hasStarted) {
            hasStarted = true; document.getElementById('hint').style.opacity = 0; document.getElementById('back-gift-btn').style.display = 'block';
            document.getElementById('bgm').play().catch(()=>{});
            new TWEEN.Tween(state).to({ bloom: 2.2, shimmer: 3.5 }, 900).easing(TWEEN.Easing.Back.Out).onComplete(() => {
                new TWEEN.Tween(state).to({ drift: 1.2, gravity: 24 }, 2800).easing(TWEEN.Easing.Quadratic.In).start();
                new TWEEN.Tween(state).to({ transition: 1, bloom: 0, shimmer: 0 }, 3600).easing(TWEEN.Easing.Quartic.InOut).start();
            }).start();
            setTimeout(()=> document.getElementById('top-tip').style.opacity=1, 1000);
            new TWEEN.Tween(camera.position).to({z: 85}, 4000).easing(TWEEN.Easing.Cubic.InOut).start();
        } else {
            const next = state.transition < 1.5 ? 2 : 1;
            new TWEEN.Tween(state).to({ transition: next }, 1500).easing(TWEEN.Easing.Exponential.InOut).start();
        }
    }

    function animate() {
        requestAnimationFrame(animate); TWEEN.update();
        if(!isDragging) points.rotation.y += 0.0015;

        const {transition:t, bloom:bl, shimmer:sh, gravity:gv, drift:df} = state;
        const time = Date.now() * 0.001;

        for (let i = 0; i < COUNT; i++) {
            const i3 = i * 3;
            let tx, ty, tz, tr, tg, tb;
            const hue = (time * 0.12 + i * 0.00003) % 1; 
            colorTool.setHSL(hue, 0.85, 0.6);
            const textR = colorTool.r, textG = colorTool.g, textB = colorTool.b;

            if (t <= 1) {
                tx = gift.pos[i3]*(1-t)+tree.pos[i3]*t; ty = gift.pos[i3+1]*(1-t)+tree.pos[i3+1]*t; tz = gift.pos[i3+2]*(1-t)+tree.pos[i3+2]*t;
                tr = gift.col[i3]*(1-t)+tree.col[i3]*t; tg = gift.col[i3+1]*(1-t)+tree.col[i3+1]*t; tb = gift.col[i3+2]*(1-t)+tree.col[i3+2]*t;
            } else {
                const t2 = t-1;
                tx = tree.pos[i3]*(1-t2)+text.pos[i3]*t2; ty = tree.pos[i3+1]*(1-t2)+text.pos[i3+1]*t2; tz = tree.pos[i3+2]*(1-t2)+text.pos[i3+2]*t2;
                tr = tree.col[i3]*(1-t2)+textR*t2; tg = tree.col[i3+1]*(1-t2)+textG*t2; tb = tree.col[i3+2]*(1-t2)+textB*t2;
            }

            const ang1 = (i * 0.137) + (df * time * 0.5); const ang2 = (i * 0.618);
            const radius = bl * 105 * (1 - Math.pow(Math.min(t, 1), 1.8)); 
            const fall = -gv * Math.pow(1 - Math.min(t, 1), 2.5) * (1 + Math.sin(i)) * 0.2;

            mixedPos[i3] = tx + Math.cos(ang1) * Math.sin(ang2) * radius;
            mixedPos[i3+1] = ty + Math.sin(ang1) * Math.sin(ang2) * radius + fall;
            mixedPos[i3+2] = tz + Math.cos(ang2) * radius;

            const flash = (Math.sin(time * 18 + i) > 0.85) ? sh : 0;
            mixedCol[i3] = tr + flash; mixedCol[i3+1] = tg + flash; mixedCol[i3+2] = tb + flash;
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
        
        if(haloPoints){
            const hp = haloPoints.geometry.attributes.position.array;
            for(let i=0; i<HALO_COUNT; i++){
                const i3 = i*3; const d = Math.sqrt(hp[i3]**2 + hp[i3+2]**2);
                hp[i3+1] = -22 + Math.sin(time * 2 + d * 0.2) * 2;
            }
            haloPoints.geometry.attributes.position.needsUpdate = true;
            haloPoints.rotation.y -= 0.001;
        }
        const sp = snowPoints.geometry.attributes.position.array;
        for (let i = 0; i < 1500; i++) { sp[i*3+1] -= 0.15; if (sp[i*3+1] < -60) sp[i*3+1] = 100; }
        snowPoints.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    init();
    </script>
</body>
</html>
